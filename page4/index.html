<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/SupercomputingKhepri/libs/katex/katex.min.css"> <link rel=stylesheet  href="/SupercomputingKhepri/libs/highlight/github.min.css"> <link rel=stylesheet  href="/SupercomputingKhepri/css/franklin.css"> <link rel=stylesheet  href="/SupercomputingKhepri/css/tufte.css"> <link rel=stylesheet  href="/SupercomputingKhepri/css/latex.css"> <link rel=stylesheet  href="/SupercomputingKhepri/css/adjust.css"> <link rel=icon  href="/SupercomputingKhepri/assets/favicon.png"> <title>Optimization</title> <div id=layout > <div id=menu > <ul> <li><a href="/SupercomputingKhepri/">Home</a> <li><a href="/SupercomputingKhepri/page1/">Introduction</a> <li><a href="/SupercomputingKhepri/page2/">Parallel Processing</a> <li><a href="/SupercomputingKhepri/page3/">Design Exploration</a> <li><a href="/SupercomputingKhepri/page4/">Optimization</a> <li><a href="/SupercomputingKhepri/page5/">Rendering</a> <li><a href="/SupercomputingKhepri/page6/">Conclusions</a> </ul> </div> <div id=main > <div class=franklin-content > <h1 id=optimization ><a href="#optimization" class=header-anchor >Optimization</a></h1> <p>The next set of experiments measured the potential gains that parallelization could provide to optimization problems. To focus on the optimization itself, we used an objective function that was not parallelized. More specifically, the case study was the optimization of the structural properties of the previous truss, measured by the maximum displacement of all its nodes. The variable vector to optimize is the location of the truss&#39; center, i.e., the point at the top where all truss arcs join.</p> <p>We started by considering only the X and Y coordinates of the truss&#39; center, fixing its height. This means we have two variables to optimize. The objective function landscape is a very simple one, as represented in the following plot where we show the maximum displacement of the truss nodes for different locations <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>X</mi><mo separator=true >,</mo><mi>Y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(X,Y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=mclose >)</span></span></span></span> &#40;at a fixed height&#41; of the truss&#39; central node.</p> <img src="/SupercomputingKhepri/assets/page4/code/output/trussCenter.svg" alt=""> <p>To make the example more interesting &#40;and to enlarge the range of variation of the objective function&#41;, we decided to also apply an horizontal force to the truss&#39; nodes, changing the objective function&#39;s landscape:</p> <img src="/SupercomputingKhepri/assets/page4/code/output/trussOffset.svg" alt=""> <p>Given that we were interested in evaluating the scalability of the optimization as the number of CPUs increases, we selected optimization algorithms that we knew were already parallelized. A suitable candidade is BlackBoxOptim, a parallelized optimization package supporting both multi- and single-objective optimization problems using metaheuristics algorithms.</p> <p>BlackBoxOptim supports both multi-threaded and parallel execution, allowing the optimization algorithm to evaluate many candidate solutions at the same time. Since Khepri is not yet thread-safe, we opted for parallel evaluation using multiple independent processes. Following the BlackBoxOptim guidelines, we used the following template:</p> <pre><code class=language-julia >using Distributed
using Random

addprocs&#40;parse&#40;Int, ARGS&#91;1&#93;&#41;-1&#41;
@everywhere include&#40;&quot;RandomDomeTruss.jl&quot;&#41;
@everywhere using BlackBoxOptim

Random.seed&#33;&#40;12345&#41;

opt &#61; bbsetup&#40;displacement,
        Method&#61;:xnes,
        SearchRange &#61; &#91;&#40;-6.0, 6.0&#41;, &#40;-6.0, 6.0&#41;&#93;,
        MaxFuncEvals &#61; 1000,
        Workers &#61; workers&#40;&#41;&#41;

res &#61; bboptimize&#40;opt&#41;

println&#40;&quot;Solution candidate:&quot;, best_candidate&#40;res&#41;&#41;
println&#40;&quot;Solution fitness:&quot;, best_fitness&#40;res&#41;&#41;</code></pre> <p>Note that the master process is responsible for running the optimization algorithm and the workers are only responsible for evaluating candidate solutions. Therefore, we fixed the seed of the master&#39;s random number generator so that we could repeat the experiments with a different number of workers but without changing the sequence of steps taken. This ensures that the optimization always finds the same solution after the same number of steps.</p> <p>Note that BlackBoxOptim requires, first, that we setup the optimization problem, using the <code>bbsetup</code> function. Here, the <code>displacement</code> argument is the function to minimize. It measures the maximum displacement of a truss&#39; node. The next argument specifies the optimization method to use, in this case, we selected the Exponential Natural Evolution Strategy &#40;xNES&#41;. Then, we specify the domain of the two variables <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> representing the projection on the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">XY</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> plane of the point where all the truss&#39; arcs join. Note that this is a square that fits inside the slab that supports the truss. We also specify the maximum number of objective function evaluations and the set of workers that will be used to compute those evaluations.</p> <p>After the setup, the function <code>bboptimize</code> does the job of coordinating the workers, assigning them candidate solutions to evaluate, collecting the results and deciding the evolution of the set of candidates.</p> <p>As before, we tested the script using an increasing number of workers and we did three independent runs to smooth out the noise. We allowed the optimization to do a maximum number of objective function evaluations of 1000. In all cases, the solution found was the same, as expected from the fixed random seed used that forced the optimization to be deterministic. The following table presents the mean time spent in the optimization process for different numbers of processes. Again, note that the number of workers is one less than the number of processes.</p> <img src="/SupercomputingKhepri/assets/page4/code/output/xnes1000.svg" alt=""> <p>Results show that the optimization clearly benefits from the use of multiple workers evaluating candidate solutions in parallel but only up to eight processes. After that, there is no benefit. We then repeated the same experiment but now using a five times larger number of objective function evaluations, i.e., 5000. The results were the following:</p> <img src="/SupercomputingKhepri/assets/page4/code/output/xnes5000.svg" alt=""> <p>As we can see, increasing the number of objective function evaluations only scales the bar chart. The overall speedups are exactly the same.</p> <p>We hypothesized that the cause for the lack of scalability was the limited size of the population that was used by default in xNES. Given that BlackBoxOptim fixes the population size at 50, we experimented increasing this to 100 in the hope that it would allow the algorithm to have more evaluations to divide among the workers. The following plots illustrates the results for a one-thousand limit in the number of function evaluations:</p> <img src="/SupercomputingKhepri/assets/page4/code/output/xnes1000pop100.svg" alt=""> <p>Once again, the speedups seem to be limited to eight processes and given that there were no expected gains after that, we stopped the process after collecting data for up to 64 processes.</p> <p>We then experimented increasing both the population size and the number of function evaluations to, respectively, 500 and 5000.</p> <img src="/SupercomputingKhepri/assets/page4/code/output/xnes500_5000.svg" alt=""> <p>As visible, there are no significant differences. The optimization seems not to scale beyond eight processes.</p> <p>The next experiment was to increase the dimensionality of the design space, by increasing the independent variables from two to three. Now, besides the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> coordinates of the central node of the truss, we also optimized its <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> coordinate, allowing it to vary between 1 and 20. We also decided to experiment running the process using just one thread, to better understand the advantages of parallelization. Fixing the maximum number of evaluations at 2000, we obtained the following results:</p> <img src="/SupercomputingKhepri/assets/page4/code/output/xnes3V.svg" alt=""> <p>Given the time it takes to produce these results, we stopped the experiment as soon as we were sure that there were no more improvements. Note the considerable gains obtained moving from one process to two, to four, and to height, with an almost constant speedup of two, but it clearly stops after we reach height processes.</p> <p>Finally, we decided to experiment with a different optimization algorithm, this time Separable Natural Evolution Strategy &#40;sNES&#41;. We used the initial set of variables &#40;just the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> coordinates of the central truss node&#41;, an initial population size of 500 and a maximum number of objective function evaluations of 5000.</p> <img src="/SupercomputingKhepri/assets/page4/code/output/snes5000.svg" alt=""> <p>In this case, there is an important speedup &#40;3X&#41; in the transition from two to four processes, that is explainable, possibly, by the fact that the transition is, in fact, from 1 worker to 3 workers, meaning that we can triple the number of objective function evaluations being done on each step. It is less clear why the previous experiments did not show the same initial speedup. In the end, we were not impressed with the speedups that we obtained from all of these experiments. We can conclude that for the specific algorithms and optimization problems that we studied, there is no justification to use more than eight processes. The good news is that this is the typical number of computing threads that are currently available in most off-the-shelf hardware. The bad news is that it does not make the case for the use of supercomputers, which have much larger numbers of threads.</p> <p>There is, however, a silver lining. In all of these experiments, we used just one computing node for each specific algorithm, but we managed to use different computing nodes for different experiments. This means that, in practice, the time needed to do the entire set of experiments is not the sum of the time needed for each experiment but the maximum of all those times, subject to the limitation that we could only explore four computing nodes and to the fact that there were other jobs competing for those resources. Nevertheless, it demonstrates the potential gains that can be obtained when addressing the No Free Lunch theorem, which states that no optimization algorithm is better than all others in all cases. The consequence is that multiple algorithms need to be tested and the ability to use multiple computing nodes allows these tests to be done simultaneously, thus taking no more time than the time needed to run the slowest of them.</p> <h1></h1> <p><a href="/SupercomputingKhepri/page3/">&lt;&lt; Previous Chapter</a></p> <p><a href="/SupercomputingKhepri/page5/">Next Chapter &gt;&gt;</a></p> <div class=page-foot > <div class=copyright > &copy; António Menezes Leitão. Last modified: April 09, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> <script src="/SupercomputingKhepri/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>